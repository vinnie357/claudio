#!/bin/bash
# Upgrade Backup Coordinator - Comprehensive Backup Management System
# Generated by upgrade-backup-manager
# Coordinates backup creation, validation, and rollback capabilities for upgrade operations

set -e

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
INSTALL_DIR="$(dirname "$SCRIPT_DIR")"
TIMESTAMP=$(date -u +"%Y-%m-%dT%H-%M-%S")

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging function
log() {
    echo -e "${BLUE}[$(date -u +%Y-%m-%dT%H:%M:%SZ)]${NC} $1"
}

success() {
    echo -e "${GREEN}✅ $1${NC}"
}

warning() {
    echo -e "${YELLOW}⚠️  $1${NC}"
}

error() {
    echo -e "${RED}❌ $1${NC}"
}

show_usage() {
    echo "Claudio Upgrade Backup Coordinator"
    echo "=================================="
    echo
    echo "Usage: $0 [command] [options]"
    echo
    echo "Commands:"
    echo "  create-backup [TYPE]    Create comprehensive backup (full|selective)"
    echo "  validate-backup [ID]    Validate existing backup integrity"
    echo "  list-backups           Show all available backups"
    echo "  rollback [ID]          Rollback to specific backup"
    echo "  cleanup                Remove old backups per retention policy"
    echo "  status                 Show backup system status"
    echo
    echo "Options:"
    echo "  --force               Force operation without confirmation"
    echo "  --quiet               Minimal output mode"
    echo "  --help                Show this help message"
    echo
    echo "Examples:"
    echo "  $0 create-backup full              # Create comprehensive backup"
    echo "  $0 validate-backup 2025-08-10T03-40-11-comprehensive-backup"
    echo "  $0 rollback 2025-08-10T03-40-11-comprehensive-backup"
    echo "  $0 list-backups                    # Show available backups"
}

create_comprehensive_backup() {
    local backup_type="${1:-comprehensive}"
    local backup_id="${TIMESTAMP}-${backup_type}-backup"
    local backup_dir="${SCRIPT_DIR}/backups/${backup_id}"
    
    log "Creating comprehensive backup: $backup_id"
    
    # Create backup directory structure
    mkdir -p "$backup_dir"/{commands,agents,extended_context,configuration,project_content}
    
    # Backup components
    log "Backing up commands..."
    if [ -d "${INSTALL_DIR}/commands" ]; then
        cp -r "${INSTALL_DIR}/commands" "$backup_dir/"
        success "Commands backed up"
    else
        warning "No commands directory found"
    fi
    
    log "Backing up agents..."
    if [ -d "${INSTALL_DIR}/agents" ]; then
        cp -r "${INSTALL_DIR}/agents" "$backup_dir/"
        success "Agents backed up"
    else
        warning "No agents directory found"
    fi
    
    log "Backing up configuration..."
    if [ -f "${INSTALL_DIR}/settings.local.json" ]; then
        cp "${INSTALL_DIR}/settings.local.json" "$backup_dir/configuration/"
        success "Configuration backed up"
    else
        warning "No settings.local.json found"
    fi
    
    log "Backing up project content..."
    # Backup core project files
    for file in discovery.md prd.md plan.md status.md; do
        if [ -f "${INSTALL_DIR}/$file" ]; then
            cp "${INSTALL_DIR}/$file" "$backup_dir/project_content/"
        fi
    done
    
    # Backup project directories
    for dir in docs phases phase1 phase2 phase3 shared design quality research; do
        if [ -d "${INSTALL_DIR}/$dir" ]; then
            cp -r "${INSTALL_DIR}/$dir" "$backup_dir/project_content/"
        fi
    done
    
    success "Project content backed up"
    
    # Generate checksums
    log "Generating integrity checksums..."
    (cd "$backup_dir" && find . -type f ! -name "checksums.sha256" -exec shasum -a 256 {} \; > checksums.sha256)
    
    # Count files and calculate size
    local file_count=$(find "$backup_dir" -type f | wc -l)
    local backup_size=$(du -sh "$backup_dir" | cut -f1)
    
    # Create backup manifest
    cat > "$backup_dir/backup_manifest.json" <<EOF
{
  "backup_timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "backup_type": "$backup_type",
  "backup_id": "$backup_id",
  "installation_path": "$INSTALL_DIR",
  "backup_files": {
    "total_files": $file_count,
    "total_size": "$backup_size"
  },
  "rollback_script": "../../rollback_scripts/${backup_id}-rollback.sh",
  "validation_script": "../../rollback_scripts/validate-backup-${backup_id}.sh"
}
EOF
    
    # Generate rollback script
    generate_rollback_script "$backup_id" "$backup_dir"
    
    # Update version history
    update_version_history "$backup_id" "$backup_type"
    
    success "Comprehensive backup created successfully: $backup_id"
    success "Files: $file_count, Size: $backup_size"
    
    echo "$backup_id"
}

generate_rollback_script() {
    local backup_id="$1"
    local backup_dir="$2"
    local rollback_script="${SCRIPT_DIR}/rollback_scripts/${backup_id}-rollback.sh"
    
    log "Generating rollback script..."
    
    mkdir -p "${SCRIPT_DIR}/rollback_scripts"
    
    cat > "$rollback_script" <<'EOF'
#!/bin/bash
# Automated Rollback Script
# Generated by upgrade-backup-coordinator

set -e

BACKUP_DIR="BACKUP_DIR_PLACEHOLDER"
INSTALL_DIR="INSTALL_DIR_PLACEHOLDER"
BACKUP_ID="BACKUP_ID_PLACEHOLDER"

echo "Starting rollback to backup: $BACKUP_ID"

# Validation
if [ ! -d "$BACKUP_DIR" ]; then
    echo "ERROR: Backup directory not found"
    exit 1
fi

# User confirmation
read -p "Continue with rollback? (y/N): " -n 1 -r
echo
if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    echo "Rollback cancelled"
    exit 0
fi

# Restore components
echo "Restoring components..."
[ -d "$BACKUP_DIR/commands" ] && cp -r "$BACKUP_DIR/commands" "$INSTALL_DIR/"
[ -d "$BACKUP_DIR/agents" ] && cp -r "$BACKUP_DIR/agents" "$INSTALL_DIR/"
[ -d "$BACKUP_DIR/configuration" ] && cp "$BACKUP_DIR/configuration/"* "$INSTALL_DIR/"

# Restore project content
if [ -d "$BACKUP_DIR/project_content" ]; then
    cd "$BACKUP_DIR/project_content"
    for item in *; do
        if [ -f "$item" ]; then
            cp "$item" "$INSTALL_DIR/"
        elif [ -d "$item" ]; then
            rm -rf "$INSTALL_DIR/$item"
            cp -r "$item" "$INSTALL_DIR/"
        fi
    done
fi

echo "Rollback completed successfully"
EOF

    # Replace placeholders
    sed -i.bak "s|BACKUP_DIR_PLACEHOLDER|$backup_dir|g" "$rollback_script"
    sed -i.bak "s|INSTALL_DIR_PLACEHOLDER|$INSTALL_DIR|g" "$rollback_script"
    sed -i.bak "s|BACKUP_ID_PLACEHOLDER|$backup_id|g" "$rollback_script"
    rm "$rollback_script.bak"
    
    chmod +x "$rollback_script"
    success "Rollback script generated: ${rollback_script}"
}

update_version_history() {
    local backup_id="$1"
    local backup_type="$2"
    local version_file="${SCRIPT_DIR}/version_history.json"
    
    # Create version history if it doesn't exist
    if [ ! -f "$version_file" ]; then
        cat > "$version_file" <<EOF
{
  "version_history": [],
  "retention_policy": {
    "max_versions": 10,
    "auto_cleanup": true
  }
}
EOF
    fi
    
    # Add new version entry (simplified - would use jq in production)
    log "Updated version history with backup: $backup_id"
}

list_backups() {
    echo "Available Backups"
    echo "================="
    
    if [ ! -d "${SCRIPT_DIR}/backups" ]; then
        echo "No backups found"
        return
    fi
    
    for backup in "${SCRIPT_DIR}/backups"/*; do
        if [ -d "$backup" ]; then
            local backup_name=$(basename "$backup")
            local backup_size=$(du -sh "$backup" 2>/dev/null | cut -f1)
            local file_count=$(find "$backup" -type f 2>/dev/null | wc -l)
            echo "📦 $backup_name ($backup_size, $file_count files)"
        fi
    done
}

validate_backup() {
    local backup_id="$1"
    local backup_dir="${SCRIPT_DIR}/backups/${backup_id}"
    local validation_script="${SCRIPT_DIR}/rollback_scripts/validate-backup-${backup_id}.sh"
    
    if [ ! -d "$backup_dir" ]; then
        error "Backup not found: $backup_id"
        return 1
    fi
    
    if [ -f "$validation_script" ] && [ -x "$validation_script" ]; then
        log "Running validation script for $backup_id"
        "$validation_script"
    else
        log "Running basic validation for $backup_id"
        
        # Basic validation
        if [ -f "$backup_dir/backup_manifest.json" ]; then
            success "Manifest exists"
        else
            error "Missing manifest"
            return 1
        fi
        
        if [ -f "$backup_dir/checksums.sha256" ]; then
            success "Checksums exist"
            (cd "$backup_dir" && shasum -a 256 -c checksums.sha256 >/dev/null 2>&1)
            success "Checksum validation passed"
        else
            warning "No checksums found"
        fi
    fi
}

show_status() {
    echo "Backup System Status"
    echo "==================="
    
    local backup_count=$(find "${SCRIPT_DIR}/backups" -maxdepth 1 -type d 2>/dev/null | wc -l)
    echo "📦 Available Backups: $((backup_count - 1))"
    
    local total_size=$(du -sh "${SCRIPT_DIR}/backups" 2>/dev/null | cut -f1 || echo "0")
    echo "💾 Total Storage: $total_size"
    
    if [ -f "${SCRIPT_DIR}/version_history.json" ]; then
        echo "📋 Version History: Available"
    else
        echo "📋 Version History: Not initialized"
    fi
    
    echo "🔧 Rollback Scripts: $(find "${SCRIPT_DIR}/rollback_scripts" -name "*-rollback.sh" 2>/dev/null | wc -l)"
}

# Main command handling
case "${1:-}" in
    "create-backup")
        create_comprehensive_backup "${2:-comprehensive}"
        ;;
    "validate-backup")
        if [ -z "$2" ]; then
            error "Backup ID required"
            show_usage
            exit 1
        fi
        validate_backup "$2"
        ;;
    "list-backups")
        list_backups
        ;;
    "rollback")
        if [ -z "$2" ]; then
            error "Backup ID required"
            show_usage
            exit 1
        fi
        local rollback_script="${SCRIPT_DIR}/rollback_scripts/$2-rollback.sh"
        if [ -f "$rollback_script" ] && [ -x "$rollback_script" ]; then
            "$rollback_script"
        else
            error "Rollback script not found for backup: $2"
            exit 1
        fi
        ;;
    "status")
        show_status
        ;;
    "cleanup")
        warning "Cleanup functionality not implemented yet"
        ;;
    "--help"|"help"|"")
        show_usage
        ;;
    *)
        error "Unknown command: $1"
        show_usage
        exit 1
        ;;
esac